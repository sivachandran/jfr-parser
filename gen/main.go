package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"slices"
	"strings"
	"text/template"

	"github.com/grafana/jfr-parser/parser/types/def"
)

func main() {
	write("types/frametype.go", generate(&Type_jdk_types_FrameType, options{
		cpool:     true,
		sortedIDs: false,
	}))
	write("types/stackframe.go", generate(&Type_jdk_types_StackFrame, options{
		skipFields: []string{
			"bytecodeIndex", "type",
		},
		cpool: false,
	}))
	write("types/threadstate.go", generate(&Type_jdk_types_ThreadState, options{
		cpool: true,
	}))
	write("types/thread.go", generate(&Type_java_lang_Thread, options{
		cpool: true,
	}))
	write("types/class.go", generate(&Type_java_lang_Class, options{
		skipFields: []string{
			"classLoader",
			"package",
			"modifiers",
		},
		cpool: true,
	}))
	write("types/classloader.go", generate(&Type_jdk_types_ClassLoader, options{
		cpool: true,
	}))
	write("types/method.go", generate(&Type_jdk_types_Method, options{
		cpool:     true,
		sortedIDs: true,
		skipFields: []string{
			"hidden",
			"descriptor",
			"modifiers",
		},
	}))
	write("types/package.go", generate(&Type_jdk_types_Package, options{
		cpool: true,
	}))
	write("types/symbol.go", generate(&Type_jdk_types_Symbol, options{
		cpool: true,
	}))
	write("types/loglevel.go", generate(&Type_profiler_types_LogLevel, options{
		cpool: true,
	}))
	write("types/stacktrace.go", generate(&Type_jdk_types_StackTrace, options{
		cpool: true,
	}))

	write("types/active_settings.go", generate(&Type_jdk_ActiveSetting, options{}))

	write("types/execution_sample.go", generate(&Type_jdk_ExecutionSample, options{}))
	write("types/allocation_in_new_tlab.go", generate(&Type_jdk_ObjectAllocationInNewTLAB, options{}))
	write("types/allocation_outside_tlab.go", generate(&Type_jdk_ObjectAllocationOutsideTLAB, options{}))
	write("types/monitor_enter.go", generate(&Type_jdk_JavaMonitorEnter, options{}))
	write("types/thread_park.go", generate(&Type_jdk_ThreadPark, options{}))
	write("types/live_object.go", generate(&Type_profiler_LiveObject, options{}))
	write("types/skipper.go", generate(&def.Class{
		Name:   "SkipConstantPool",
		ID:     0,
		Fields: []def.Field{},
	}, options{
		cpool:         true,
		doNotKeepData: true,
	}))

}

func write(dst, s string) {
	formattedSource, err := format.Source([]byte(s))
	if err != nil {
		fmt.Println(s)
		panic(err)
	}
	err = os.WriteFile("parser/"+dst, formattedSource, 0666)
	if err != nil {
		panic(err)
	}
}

type options struct {
	cpool         bool
	sortedIDs     bool
	doNotKeepData bool
	skipFields    []string //todo make skip fields runtime option, but still saving memory - explode struct to fields
}

func TypeForCPoolID(ID def.TypeID) *def.Class {
	switch ID {
	case T_FRAME_TYPE:
		return &Type_jdk_types_FrameType
	case T_THREAD_STATE:
		return &Type_jdk_types_ThreadState
	case T_THREAD:
		return &Type_java_lang_Thread
	case T_CLASS:
		return &Type_java_lang_Class
	case T_METHOD:
		return &Type_jdk_types_Method
	case T_PACKAGE:
		return &Type_jdk_types_Package
	case T_SYMBOL:
		return &Type_jdk_types_Symbol
	case T_LOG_LEVEL:
		return &Type_profiler_types_LogLevel
	case T_STACK_TRACE:
		return &Type_jdk_types_StackTrace
	case T_CLASS_LOADER:
		return &Type_jdk_types_ClassLoader
	case T_STACK_FRAME:
		return &Type_jdk_types_StackFrame
	default:
		panic("unknown type " + TypeID2Sym(ID))
	}
}

func generate(typ *def.Class, opt options) string {
	tmplText := `
		// Code generated by gen/main.go. DO NOT EDIT.

		package types

		import (
			"fmt"
			
			"github.com/grafana/jfr-parser/parser/types/def"
			"github.com/grafana/jfr-parser/util"
		)

		type {{.BindName}} struct {
			Temp 	{{.Name}}
			Fields	[]{{.BindFieldName}}
		}

		type {{.BindFieldName}} struct {
			Field	*def.Field
			{{range .UniqueFields}}
			{{- goTypeName .}}	*{{if .Array}}[]{{end}}{{goTypeName .}}
			{{end}}
		}

		func New{{.BindName}}(typ *def.Class, typeMap *def.TypeMap) *{{.BindName}} {
			res := new({{.BindName}})
			res.Fields = make([]{{.BindFieldName}}, 0, len(typ.Fields))
			for i := 0; i < len(typ.Fields); i++ {
				switch typ.Fields[i].Name {
				{{- range .Fields}}
				case "{{.Name}}":
					{{- if skipField .Name}}
						res.Fields = append(res.Fields, {{$.BindFieldName}}{Field: &typ.Fields[i]}) // skip to save mem
					{{- else}}
						if typ.Fields[i].Equals(&def.Field{Name: "{{.Name}}", Type: typeMap.{{typeID2Sym .Type}}, ConstantPool: {{.ConstantPool}}, Array: {{.Array}}}) {
							res.Fields = append(res.Fields, {{$.BindFieldName}}{Field: &typ.Fields[i], {{goTypeName .}}: &res.Temp.{{capitalize .Name}}})
						} else {
							res.Fields = append(res.Fields, {{$.BindFieldName}}{Field: &typ.Fields[i]}) // skip changed field
						}
					{{- end}}
				{{- end}}
				default:
					res.Fields = append(res.Fields, {{.BindFieldName}}{Field: &typ.Fields[i]}) // skip unknown new field
				}
			}
			return res
		}

		{{- if .CPool}}

			type {{.RefName}} uint32
			type {{.ListName}} struct {

				{{- if .DoNotKeepData}}
				{{- else}}

					{{- if .SortedIDs}}
						IDMap	IDMap[{{.RefName}}]
					{{- else}}
						IDMap	map[{{.RefName}}]uint32
					{{- end}}
					{{.Name}}	[]{{.Name}}

				{{- end}}

			}

		{{- end}}

		type {{.Name}} struct {

			{{- range .Fields}}

				{{- if skipField .Name}}
					// skip {{.Name}}
				{{- else}}

					{{- if .Array}}
						{{capitalize .Name}}	[]{{goTypeName .}}
					{{- else}}
						{{capitalize .Name}}	{{goTypeName .}}
					{{- end}}

				{{- end}}

			{{- end}}
		}

		func (this *{{.Name}}{{- if .CPool}}List{{- end}}) Parse(data []byte, bind *{{.BindName}} {{- range .NonBasicFields}}, bind{{typeNameForCPoolID .Type}} *{{bindNameForCPoolID .Type}}{{- end}}, typeMap *def.TypeMap) (pos int, err error) {
			{{- if .CPool}}

				v32_, err := util.ParseVarInt(data, &pos)
				if err != nil {
					return 0, err
				}
				n := int(v32_)
				{{- if .DoNotKeepData}}
				{{- else}}
					{{- if .SortedIDs}}
						this.IDMap = NewIDMap[{{.RefName}}](n)
					{{- else}}
						this.IDMap = make(map[{{.RefName}}]uint32, n)
					{{- end}}
					this.{{.Name}} = make([]{{.Name}}, n)
				{{- end}}
				for i := 0; i < n; i++ {

					v32_, err = util.ParseVarInt(data, &pos)
					if err != nil {
						return 0, err
					}
					{{- if .DoNotKeepData}}
					{{- else}}
						id := {{.RefName}}(v32_)
					{{- end}}
			{{- end}}
			{{.GeneratedBindLoop}}
			{{- if .CPool}}
				{{- if .DoNotKeepData}}
				{{- else}}
					this.{{.Name}}[i] = bind.Temp
					{{- if .SortedIDs}}
						this.IDMap.Set(id, i)
					{{- else}}
						this.IDMap[id] = uint32(i)
					{{- end}}
				{{- end}}
				}
			{{- else}}
			*this = bind.Temp
			{{- end}}
			return pos, nil
		}
	`
	tmpl, err := template.New("").Funcs(template.FuncMap{
		"name":          name,
		"bindName":      bindName,
		"bindFieldName": bindFieldName,
		"goTypeName":    goTypeName,
		"skipField": func(name string) bool {
			return slices.Contains(opt.skipFields, name)
		},
		"capitalize": capitalize,
		"typeNameForCPoolID": func(typeID def.TypeID) string {
			return name(TypeForCPoolID(typeID))
		},
		"bindNameForCPoolID": func(typeID def.TypeID) string {
			return bindName(TypeForCPoolID(typeID))
		},
		"typeID2Sym": TypeID2Sym,
	}).Parse(tmplText)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, struct {
		CPool             bool
		DoNotKeepData     bool
		SortedIDs         bool
		Type              *def.Class
		Name              string
		BindName          string
		BindFieldName     string
		RefName           string
		ListName          string
		UniqueFields      []def.Field
		Fields            []def.Field
		NonBasicFields    []def.Field
		GeneratedBindLoop string
	}{
		CPool:             opt.cpool,
		DoNotKeepData:     opt.doNotKeepData,
		SortedIDs:         opt.sortedIDs,
		Type:              typ,
		Name:              name(typ),
		BindName:          bindName(typ),
		BindFieldName:     bindFieldName(typ),
		RefName:           refName(typ),
		ListName:          listName(typ),
		UniqueFields:      getUniqueFields(typ),
		Fields:            typ.Fields,
		NonBasicFields:    getNonBasicFields(typ),
		GeneratedBindLoop: strings.Trim(generateBindLoop(typ, "bind", true), "\n"),
	})
	if err != nil {
		panic(err)
	}

	return buf.String()
}

func generateBindLoop(typ *def.Class, bindName string, nestedAllowed bool) string {
	uniqueFields := getUniqueFields(typ)

	tmplText := `
		for {{.BindName}}FieldIndex := 0; {{.BindName}}FieldIndex < len({{.BindName}}.Fields); {{.BindName}}FieldIndex++ {
			{{.BindName}}ArraySize := 1
			if {{.BindName}}.Fields[{{.BindName}}FieldIndex].Field.Array {
				v32_, err := util.ParseVarInt(data, &pos)
				if err != nil {
					return 0, err
				}
				{{.BindName}}ArraySize = int(v32_)
				{{- if .NonBasicFields}}
					{{$firstNonBasicField := index .NonBasicFields 0}}
					if {{.BindName}}.Fields[{{.BindName}}FieldIndex].Field.Type == typeMap.{{typeID2Sym $firstNonBasicField.Type}} {
						*{{.BindName}}.Fields[{{.BindName}}FieldIndex].{{typeNameForCPoolID $firstNonBasicField.Type}} = make([]{{typeNameForCPoolID $firstNonBasicField.Type}}, 0, {{.BindName}}ArraySize)
					}						
				{{- end}}
			}
			for {{.BindName}}ArrayIndex := 0; {{.BindName}}ArrayIndex < {{.BindName}}ArraySize; {{.BindName}}ArrayIndex++ {
				if {{.BindName}}.Fields[{{.BindName}}FieldIndex].Field.ConstantPool {
					v32_, err := util.ParseVarInt(data, &pos)
					if err != nil {
						return 0, err
					}
					{{- if .CPoolFields}}
						switch {{$.BindName}}.Fields[{{$.BindName}}FieldIndex].Field.Type {
							{{- range .CPoolFields}}
								case typeMap.{{typeID2Sym .Type}}:
									{{- $fieldGoTypeName := (goTypeName .) }}
									if {{$.BindName}}.Fields[{{$.BindName}}FieldIndex].{{$fieldGoTypeName}} != nil {
										*{{$.BindName}}.Fields[{{$.BindName}}FieldIndex].{{$fieldGoTypeName}} = {{$fieldGoTypeName}}(v32_)
									}
							{{- end}}
						}
					{{- else}}
						_ = v32_
					{{- end}}
				} else {
					{{.BindName}}FieldTypeID := {{.BindName}}.Fields[{{.BindName}}FieldIndex].Field.Type
					switch {{.BindName}}FieldTypeID {
					case  typeMap.T_STRING:
						s_, err := util.ParseString(data, &pos)
						if err != nil {
							return 0, err
						}
						{{- if .HasStringField}}
							if {{.BindName}}.Fields[{{.BindName}}FieldIndex].string != nil {
								*{{.BindName}}.Fields[{{.BindName}}FieldIndex].string = s_
							}
						{{- else}}
							// skipping
							_ = s_
						{{- end}}
					case typeMap.T_INT:
						v32_, err := util.ParseVarInt(data, &pos)
						if err != nil {
							return 0, err
						}
						{{- if .HasIntField}}
							if {{.BindName}}.Fields[{{.BindName}}FieldIndex].uint32 != nil {
								*{{.BindName}}.Fields[{{.BindName}}FieldIndex].uint32 = v32_
							}
						{{- else}}
							// skipping
							_ = v32_
						{{- end}}
					case typeMap.T_LONG:
						v64_, err := util.ParseVarLong(data, &pos)
						if err != nil {
							return 0, err
						}
						{{- if .HasLongField}}
							if {{.BindName}}.Fields[{{.BindName}}FieldIndex].uint64 != nil {
								*{{.BindName}}.Fields[{{.BindName}}FieldIndex].uint64 = v64_
							}
						{{- else}}
							// skipping
							_ = v64_
						{{- end}}
					case typeMap.T_BOOLEAN:
						b_, err := util.ParseByte(data, &pos)
						if err != nil {
							return 0, err
						}
						{{- if .HasBoolField}}
							if {{.BindName}}.Fields[{{.BindName}}FieldIndex].bool != nil {
								*{{.BindName}}.Fields[{{.BindName}}FieldIndex].bool = b_ != 0
							}
						{{- else}}
							// skipping
							_ = b_
						{{- end}}
					case typeMap.T_FLOAT:
						v32_, err := util.ParseVarInt(data, &pos)
						if err != nil {
							return 0, err
						}
						{{- if .HasFloatField}}
							if {{.BindName}}.Fields[{{.BindName}}FieldIndex].float32 != nil {
								*{{.BindName}}.Fields[{{.BindName}}FieldIndex].bool = *(*float32)(unsafe.Pointer(&v32_))
							}
						{{- else}}
							// skipping
							_ = v32_
						{{- end}}
					{{- if .NestedAllowed}}
						{{- range .NonBasicFields}}
							{{- $nestedType := (typeForCPoolID .Type)}}
							{{- $nestedTypeName := (name $nestedType)}}
							case typeMap.{{typeID2Sym .Type}}:
								{{- nestedTypeBindLoop $nestedType}}
								{{- if .Array}}
									if {{$.BindName}}.Fields[{{$.BindName}}FieldIndex].{{$nestedTypeName}} != nil {
										*{{$.BindName}}.Fields[{{$.BindName}}FieldIndex].{{$nestedTypeName}} = append(*{{$.BindName}}.Fields[{{$.BindName}}FieldIndex].{{$nestedTypeName}}, bind{{$nestedTypeName}}.Temp)
									}
								{{- else}}
									{{panic (printf "nested type not implemented for %s" .String)}}
								{{- end}}
						{{- end}}
					{{- end}}
					default:
						{{.BindName}}FieldType := typeMap.IDMap[{{.BindName}}.Fields[{{.BindName}}FieldIndex].Field.Type]
						if {{.BindName}}FieldType == nil || len({{.BindName}}FieldType.Fields) == 0 {
							return 0, fmt.Errorf("unknown type %d", {{.BindName}}.Fields[{{.BindName}}FieldIndex].Field.Type)
						}
						{{.BindName}}SkipObjects := 1
						if {{.BindName}}.Fields[{{.BindName}}FieldIndex].Field.Array {
							v32_, err := util.ParseVarInt(data, &pos)
							if err != nil {
								return 0, err
							}
							{{.BindName}}SkipObjects = int(v32_)
						}
						for {{.BindName}}SkipObjectIndex := 0; {{.BindName}}SkipObjectIndex < {{.BindName}}SkipObjects; {{.BindName}}SkipObjectIndex++ {
							for {{.BindName}}skipFieldIndex := 0; {{.BindName}}skipFieldIndex < len({{.BindName}}FieldType.Fields); {{.BindName}}skipFieldIndex++ {
								{{.BindName}}SkipFieldType :=  {{.BindName}}FieldType.Fields[{{.BindName}}skipFieldIndex].Type
								if {{.BindName}}FieldType.Fields[{{.BindName}}skipFieldIndex].ConstantPool {
									_, err := util.ParseVarInt(data, &pos)
									if err != nil {
										return 0, err
									}
								} else if {{.BindName}}SkipFieldType == typeMap.T_STRING{
									_, err := util.ParseString(data, &pos)
									if err != nil {
										return 0, err
									}
								} else if {{.BindName}}SkipFieldType == typeMap.T_INT {
									_, err := util.ParseVarInt(data, &pos)
									if err != nil {
										return 0, err
									}
								} else if {{.BindName}}SkipFieldType == typeMap.T_FLOAT {
									_, err := util.ParseVarInt(data, &pos)
									if err != nil {
										return 0, err
									}
								} else if {{.BindName}}SkipFieldType == typeMap.T_LONG {
									_, err := util.ParseVarLong(data, &pos)
									if err != nil {
										return 0, err
									}
								} else if {{.BindName}}SkipFieldType == typeMap.T_BOOLEAN {
									_, err := util.ParseByte(data, &pos)
									if err != nil {
										return 0, err
									}
								} else {
									return 0, fmt.Errorf("nested objects not implemented. ")
								}
							}
						}
					}
				}
			}
		}
	`
	tmpl, err := template.New("").Funcs(template.FuncMap{
		"name":           name,
		"goTypeName":     goTypeName,
		"capitalize":     capitalize,
		"typeForCPoolID": TypeForCPoolID,
		"typeNameForCPoolID": func(typeID def.TypeID) string {
			return name(TypeForCPoolID(typeID))
		},
		"typeID2Sym": TypeID2Sym,
		"nestedTypeBindLoop": func(nestedType *def.Class) string {
			return strings.Trim(generateBindLoop(nestedType, "bind"+name(nestedType), false), "\n")
		},
		"panic": func(msg string) string {
			panic(msg)
		},
	}).Parse(tmplText)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, struct {
		Name           string
		BindName       string
		RefName        string
		ListName       string
		Fields         []def.Field
		CPoolFields    []def.Field
		NonBasicFields []def.Field
		NestedAllowed  bool
		HasStringField bool
		HasIntField    bool
		HasLongField   bool
		HasBoolField   bool
		HasFloatField  bool
	}{
		Name:           name(typ),
		BindName:       bindName,
		RefName:        refName(typ),
		ListName:       listName(typ),
		Fields:         typ.Fields,
		CPoolFields:    getUniqueCPoolFields(typ),
		NonBasicFields: getNonBasicFields(typ),
		NestedAllowed:  nestedAllowed,
		HasStringField: fieldsHas(uniqueFields, T_STRING),
		HasIntField:    fieldsHas(uniqueFields, T_INT),
		HasLongField:   fieldsHas(uniqueFields, T_LONG),
		HasBoolField:   fieldsHas(uniqueFields, T_BOOLEAN),
		HasFloatField:  fieldsHas(uniqueFields, T_FLOAT),
	})
	if err != nil {
		panic(err)
	}

	return buf.String()
}

func fieldsHas(fs []def.Field, tString def.TypeID) bool {
	for _, f := range fs {
		if f.Type == tString {
			return true
		}
	}
	return false
}

func getUniqueFields(typ *def.Class) []def.Field {
	res := make([]def.Field, 0, len(typ.Fields))
	for j := range typ.Fields {
		found := false
		fieldCopy := typ.Fields[j]
		fieldCopy.Name = ""
		for i := 0; i < len(res); i++ {
			if res[i].Equals(&fieldCopy) {
				found = true
				break
			}
		}
		if !found {
			res = append(res, fieldCopy)
		}
	}
	return res
}

func getUniqueCPoolFields(typ *def.Class) []def.Field {
	fs := getUniqueFields(typ)
	res := make([]def.Field, 0, len(fs))
	for _, f := range fs {
		if f.ConstantPool {
			res = append(res, f)
		}
	}
	return res
}

func getNonBasicFields(typ *def.Class) []def.Field {

	res := make([]def.Field, 0, len(typ.Fields))
	for _, f := range typ.Fields {
		if f.ConstantPool {
			continue
		}
		if f.Type == T_INT || f.Type == T_LONG || f.Type == T_FLOAT || f.Type == T_BOOLEAN || f.Type == T_STRING {
			continue
		}
		res = append(res, f)
	}
	return res
}

func goTypeName(field def.Field) string {
	if field.ConstantPool {
		//todo array is not tested
		return name(TypeForCPoolID(field.Type)) + "Ref"
	}
	switch field.Type {
	case T_STRING:
		return "string"
	case T_LONG:
		return "uint64"
	case T_INT:
		return "uint32"
	case T_FLOAT:
		return "float32"
	case T_BOOLEAN:
		return "bool"
	case T_STACK_FRAME:
		return "StackFrame" //todo make it generic
	default:
		panic("TODO " + field.String())
	}
}

func name(typ *def.Class) string {
	fs := strings.Split(typ.Name, ".")
	s := fs[len(fs)-1]
	return capitalize(s)
}

func bindName(typ *def.Class) string {
	return "Bind" + name(typ)
}
func bindFieldName(typ *def.Class) string {
	return "BindField" + name(typ)
}
func refName(typ *def.Class) string {
	return name(typ) + "Ref"
}

func listName(typ *def.Class) string {
	return name(typ) + "List"
}

func capitalize(s string) string {
	return strings.ToUpper(s[:1]) + s[1:]
}
