package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"slices"
	"strings"
	"text/template"

	"github.com/grafana/jfr-parser/parser/types/def"
)

func main() {
	write("types/frametype.go", generate(&Type_jdk_types_FrameType, options{
		cpool:     true,
		sortedIDs: false,
	}))
	write("types/stackframe.go", generate(&Type_jdk_types_StackFrame, options{
		skipFields: []string{
			"bytecodeIndex", "type",
		},
		cpool: false,
	}))
	write("types/threadstate.go", generate(&Type_jdk_types_ThreadState, options{
		cpool: true,
	}))
	write("types/thread.go", generate(&Type_java_lang_Thread, options{
		cpool: true,
	}))
	write("types/class.go", generate(&Type_java_lang_Class, options{
		skipFields: []string{
			"classLoader",
			"package",
			"modifiers",
		},
		cpool: true,
	}))
	write("types/classloader.go", generate(&Type_jdk_types_ClassLoader, options{
		cpool: true,
	}))
	write("types/method.go", generate(&Type_jdk_types_Method, options{
		cpool:     true,
		sortedIDs: true,
		skipFields: []string{
			"hidden",
			"descriptor",
			"modifiers",
		},
	}))
	write("types/package.go", generate(&Type_jdk_types_Package, options{
		cpool: true,
	}))
	write("types/symbol.go", generate(&Type_jdk_types_Symbol, options{
		cpool: true,
	}))
	write("types/loglevel.go", generate(&Type_profiler_types_LogLevel, options{
		cpool: true,
	}))
	write("types/stacktrace.go", generate(&Type_jdk_types_StackTrace, options{
		cpool: true,
	}))

	write("types/active_settings.go", generate(&Type_jdk_ActiveSetting, options{}))

	write("types/execution_sample.go", generate(&Type_jdk_ExecutionSample, options{}))
	write("types/allocation_in_new_tlab.go", generate(&Type_jdk_ObjectAllocationInNewTLAB, options{}))
	write("types/allocation_outside_tlab.go", generate(&Type_jdk_ObjectAllocationOutsideTLAB, options{}))
	write("types/monitor_enter.go", generate(&Type_jdk_JavaMonitorEnter, options{}))
	write("types/thread_park.go", generate(&Type_jdk_ThreadPark, options{}))
	write("types/live_object.go", generate(&Type_profiler_LiveObject, options{}))
	write("types/skipper.go", generate(&def.Class{
		Name:   "SkipConstantPool",
		ID:     0,
		Fields: []def.Field{},
	}, options{
		cpool:         true,
		doNotKeepData: true,
	}))

}

func write(dst, s string) {
	formattedSource, err := format.Source([]byte(s))
	if err != nil {
		fmt.Println(s)
		panic(err)
	}
	err = os.WriteFile("parser/"+dst, formattedSource, 0666)
	if err != nil {
		panic(err)
	}
}

type options struct {
	cpool         bool
	sortedIDs     bool
	doNotKeepData bool
	skipFields    []string //todo make skip fields runtime option, but still saving memory - explode struct to fields
}

func TypeForCPoolID(ID def.TypeID) *def.Class {
	switch ID {
	case T_FRAME_TYPE:
		return &Type_jdk_types_FrameType
	case T_THREAD_STATE:
		return &Type_jdk_types_ThreadState
	case T_THREAD:
		return &Type_java_lang_Thread
	case T_CLASS:
		return &Type_java_lang_Class
	case T_METHOD:
		return &Type_jdk_types_Method
	case T_PACKAGE:
		return &Type_jdk_types_Package
	case T_SYMBOL:
		return &Type_jdk_types_Symbol
	case T_LOG_LEVEL:
		return &Type_profiler_types_LogLevel
	case T_STACK_TRACE:
		return &Type_jdk_types_StackTrace
	case T_CLASS_LOADER:
		return &Type_jdk_types_ClassLoader
	case T_STACK_FRAME:
		return &Type_jdk_types_StackFrame
	default:
		panic("unknown type " + TypeID2Sym(ID))
	}
}

func generate(typ *def.Class, opt options) string {
	tmplText := `
		// Code generated by gen/main.go. DO NOT EDIT.

		package types

		import (
			"fmt"
			
			"github.com/grafana/jfr-parser/parser/types/def"
			"github.com/grafana/jfr-parser/util"
		)
		{{.GeneratedBinding}}
		{{- if .CPool}}

			type {{.RefName}} uint32
			type {{.ListName}} struct {

				{{- if .DoNotKeepData}}
				{{- else}}

					{{- if .SortedIDs}}
						IDMap	IDMap[{{.RefName}}]
					{{- else}}
						IDMap	map[{{.RefName}}]uint32
					{{- end}}
					{{.Name}}	[]{{.Name}}

				{{- end}}

			}

		{{- end}}

		type {{.Name}} struct {

			{{- range .Fields}}

				{{- if skipField .Name}}
					// skip {{.Name}}
				{{- else}}

					{{- if .Array}}
						{{capitalize .Name}}	[]{{goTypeName .}}
					{{- else}}
						{{capitalize .Name}}	{{goTypeName .}}
					{{- end}}

				{{- end}}

			{{- end}}
		}

		func (this *{{.Name}}{{- if .CPool}}List{{- end}}) Parse(data []byte, bind *{{.BindName}} {{- range .NonBasicFields}}, bind{{typeNameForCPoolID .Type}} *{{bindNameForCPoolID .Type}}{{- end}}, typeMap *def.TypeMap) (pos int, err error) {
			{{- if .CPool}}

				v32_, err := util.ParseVarInt(data, &pos)
				if err != nil {
					return 0, err
				}
				n := int(v32_)
				{{- if .DoNotKeepData}}
				{{- else}}
					{{- if .SortedIDs}}
						this.IDMap = NewIDMap[{{.RefName}}](n)
					{{- else}}
						this.IDMap = make(map[{{.RefName}}]uint32, n)
					{{- end}}
					this.{{.Name}} = make([]{{.Name}}, n)
				{{- end}}
				for i := 0; i < n; i++ {

					v32_, err = util.ParseVarInt(data, &pos)
					if err != nil {
						return 0, err
					}
					{{- if .DoNotKeepData}}
					{{- else}}
						id := {{.RefName}}(v32_)
					{{- end}}
			{{- end}}
			{{.GeneratedBindLoop}}
			{{- if .CPool}}
				{{- if .DoNotKeepData}}
				{{- else}}
					this.{{.Name}}[i] = bind.Temp
					{{- if .SortedIDs}}
						this.IDMap.Set(id, i)
					{{- else}}
						this.IDMap[id] = uint32(i)
					{{- end}}
				{{- end}}
				}
			{{- else}}
			*this = bind.Temp
			{{- end}}
			return pos, nil
		}
	`
	tmpl, err := template.New("").Funcs(template.FuncMap{
		"goTypeName": goTypeName,
		"skipField": func(name string) bool {
			return slices.Contains(opt.skipFields, name)
		},
		"capitalize": capitalize,
		"typeNameForCPoolID": func(typeID def.TypeID) string {
			return name(TypeForCPoolID(typeID))
		},
		"bindNameForCPoolID": func(typeID def.TypeID) string {
			return bindName(TypeForCPoolID(typeID))
		},
	}).Parse(tmplText)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, struct {
		CPool             bool
		DoNotKeepData     bool
		SortedIDs         bool
		Name              string
		BindName          string
		RefName           string
		ListName          string
		Fields            []def.Field
		NonBasicFields    []def.Field
		GeneratedBinding  string
		GeneratedBindLoop string
	}{
		CPool:             opt.cpool,
		DoNotKeepData:     opt.doNotKeepData,
		SortedIDs:         opt.sortedIDs,
		Name:              name(typ),
		BindName:          bindName(typ),
		RefName:           refName(typ),
		ListName:          listName(typ),
		Fields:            typ.Fields,
		NonBasicFields:    getNonBasicFields(typ),
		GeneratedBinding:  generateBinding(typ, opt),
		GeneratedBindLoop: strings.Trim(generateBindLoop(typ, "bind", 2, true), "\n"),
	})
	if err != nil {
		panic(err)
	}

	res := buf.String()
	fmt.Println(res)

	fmt.Println("types2.ExpectedMeta" + name(typ) + ",")
	//fmt.Println(res)
	return res
}

func generateBindLoop(typ *def.Class, bindName string, nestedAllowed bool) string {
	fs := getUniqueFields(typ)
	cpoolFields := getUniqueCpoolFields(typ)
	complexFields := getNonBasicFields(typ)
	_ = complexFields
	res := ""

	res += fmt.Sprintf("for %sFieldIndex := 0; %sFieldIndex < len(%s.Fields); %sFieldIndex++ {\n", bindName, bindName, bindName, bindName)
	res += fmt.Sprintf("	%sArraySize := 1\n", bindName)
	res += fmt.Sprintf("	if %s.Fields[%sFieldIndex].Field.Array {\n", bindName, bindName)
	res += emitReadI32()
	res += fmt.Sprintf("		%sArraySize = int(v32_)\n", bindName)
	if len(complexFields) > 0 {
		res += fmt.Sprintf("		if %s.Fields[%sFieldIndex].Field.Type == typeMap.%s {\n", bindName, bindName, TypeID2Sym(complexFields[0].Type))
		res += fmt.Sprintf("			*%s.Fields[%sFieldIndex].%s = make([]%s, 0, %sArraySize)\n",
			bindName, bindName, name(TypeForCPoolID(complexFields[0].Type)), name(TypeForCPoolID(complexFields[0].Type)), bindName)
		res += fmt.Sprintf("		}\n")
	}
	res += fmt.Sprintf("	}\n")
	res += fmt.Sprintf("	for %sArrayIndex := 0; %sArrayIndex < %sArraySize; %sArrayIndex++ {\n", bindName, bindName, bindName, bindName)
	res += fmt.Sprintf("	if %s.Fields[%sFieldIndex].Field.ConstantPool {\n", bindName, bindName)
	res += emitReadI32()
	if len(cpoolFields) > 0 {
		res += fmt.Sprintf("		switch %s.Fields[%sFieldIndex].Field.Type {\n", bindName, bindName)
		for _, field := range cpoolFields {
			res += fmt.Sprintf("		case typeMap.%s:\n", TypeID2Sym(field.Type))
			res += fmt.Sprintf("			if %s.Fields[%sFieldIndex].%s != nil {\n", bindName, bindName, goTypeName(field))
			res += fmt.Sprintf("				*%s.Fields[%sFieldIndex].%s = %s(v32_)\n", bindName, bindName, goTypeName(field), goTypeName(field))
			res += fmt.Sprintf("			}\n")
		}
		res += fmt.Sprintf("		}\n")
	}
	res += fmt.Sprintf("	} else {\n")
	res += fmt.Sprintf("		%sFieldTypeID := %s.Fields[%sFieldIndex].Field.Type\n", bindName, bindName, bindName)

	res += fmt.Sprintf("		switch %sFieldTypeID {\n", bindName)
	res += fmt.Sprintf("		case  typeMap.T_STRING:\n")
	res += emitString()
	if fieldsHas(fs, T_STRING) {
		res += fmt.Sprintf("			if %s.Fields[%sFieldIndex].string != nil {\n", bindName, bindName)
		res += fmt.Sprintf("				*%s.Fields[%sFieldIndex].string = s_\n", bindName, bindName)
		res += fmt.Sprintf("			}\n")
	} else {
		res += fmt.Sprintf("			// skipping\n")
	}

	res += fmt.Sprintf("		case typeMap.T_INT:\n")
	res += emitReadI32()
	if fieldsHas(fs, T_INT) {
		res += fmt.Sprintf("			if %s.Fields[%sFieldIndex].uint32 != nil {\n", bindName, bindName)
		res += fmt.Sprintf("				*%s.Fields[%sFieldIndex].uint32 = v32_\n", bindName, bindName)
		res += fmt.Sprintf("			}\n")
	} else {
		res += fmt.Sprintf("			// skipping\n")
	}
	res += fmt.Sprintf("		case typeMap.T_LONG:\n")
	res += emitReadU64()
	if fieldsHas(fs, T_LONG) {
		res += fmt.Sprintf("			if %s.Fields[%sFieldIndex].uint64 != nil {\n", bindName, bindName)
		res += fmt.Sprintf("				*%s.Fields[%sFieldIndex].uint64 = v64_\n", bindName, bindName)
		res += fmt.Sprintf("			}\n")
	} else {
		res += fmt.Sprintf("			// skipping\n")
	}

	res += fmt.Sprintf("		case typeMap.T_BOOLEAN:\n")
	res += emitReadByte()
	if fieldsHas(fs, T_BOOLEAN) {
		res += fmt.Sprintf("			if %s.Fields[%sFieldIndex].bool != nil {\n", bindName, bindName)
		res += fmt.Sprintf("				*%s.Fields[%sFieldIndex].bool = b_ != 0\n", bindName, bindName)
		res += fmt.Sprintf("			}\n")
	} else {
		res += fmt.Sprintf("			// skipping\n")
	}
	res += fmt.Sprintf("		case typeMap.T_FLOAT:\n")
	res += emitReadI32()
	if fieldsHas(fs, T_FLOAT) {
		res += fmt.Sprintf("			if %s.Fields[%sFieldIndex].float32 != nil {\n", bindName, bindName)
		res += fmt.Sprintf("				*%s.Fields[%sFieldIndex].float32 = *(*float32)(unsafe.Pointer(&v32_))\n", bindName, bindName)
		res += fmt.Sprintf("			}\n")
	} else {
		res += fmt.Sprintf("			// skipping\n")
	}
	if nestedAllowed {
		for _, field := range complexFields {
			nestedType := TypeForCPoolID(field.Type)
			res += fmt.Sprintf("		case typeMap.%s:\n", TypeID2Sym(field.Type))
			res += generateBindLoop(nestedType, "bind"+name(nestedType), false)
			if field.Array {
				res += fmt.Sprintf("			if %s.Fields[%sFieldIndex].%s != nil {\n", bindName, bindName, name(nestedType))
				res += fmt.Sprintf("				*%s.Fields[%sFieldIndex].%s = append(*%s.Fields[%sFieldIndex].%s, bind%s.Temp)\n", bindName, bindName, name(nestedType), bindName, bindName, name(nestedType), name(nestedType))
				res += fmt.Sprintf("			}\n")
			} else {
				panic("TODO " + field.String())
			}
		}
	}
	res += fmt.Sprintf("		default:\n")
	//todo array
	res += fmt.Sprintf("			%sFieldType := typeMap.IDMap[%s.Fields[%sFieldIndex].Field.Type]\n", bindName, bindName, bindName)
	res += fmt.Sprintf("			if %sFieldType == nil || len(%sFieldType.Fields) == 0 {\n", bindName, bindName)
	res += fmt.Sprintf("				return 0, fmt.Errorf(\"unknown type %%d\", %s.Fields[%sFieldIndex].Field.Type)\n", bindName, bindName)
	res += fmt.Sprintf("			}\n")
	res += fmt.Sprintf("			%sSkipObjects := 1\n", bindName)
	res += fmt.Sprintf("			if %s.Fields[%sFieldIndex].Field.Array {\n", bindName, bindName)
	res += emitReadI32()
	res += fmt.Sprintf("				%sSkipObjects = int(v32_)\n", bindName)
	res += fmt.Sprintf("			}\n")
	res += fmt.Sprintf("			for %sSkipObjectIndex := 0; %sSkipObjectIndex < %sSkipObjects; %sSkipObjectIndex++ {\n", bindName, bindName, bindName, bindName)
	res += fmt.Sprintf("				for %sskipFieldIndex := 0; %sskipFieldIndex < len(%sFieldType.Fields); %sskipFieldIndex++ {\n", bindName, bindName, bindName, bindName)
	res += fmt.Sprintf("					%sSkipFieldType :=  %sFieldType.Fields[%sskipFieldIndex].Type\n", bindName, bindName, bindName)
	res += fmt.Sprintf("					if %sFieldType.Fields[%sskipFieldIndex].ConstantPool {\n", bindName, bindName)
	res += emitReadI32()
	res += fmt.Sprintf("					} else if %sSkipFieldType == typeMap.T_STRING{\n", bindName)
	res += emitString()
	res += fmt.Sprintf("					} else if %sSkipFieldType == typeMap.T_INT {\n", bindName)
	res += emitReadI32()
	res += fmt.Sprintf("					} else if %sSkipFieldType == typeMap.T_FLOAT {\n", bindName)
	res += emitReadI32()
	res += fmt.Sprintf("					} else if %sSkipFieldType == typeMap.T_LONG {\n", bindName)
	res += emitReadU64()
	res += fmt.Sprintf("					} else if %sSkipFieldType == typeMap.T_BOOLEAN {\n", bindName)
	res += emitReadByte()
	res += fmt.Sprintf("					} else {\n")
	res += fmt.Sprintf("							return 0, fmt.Errorf(\"nested objects not implemented. \")\n")
	res += fmt.Sprintf("					}\n")
	res += fmt.Sprintf("				}\n")
	res += fmt.Sprintf("			}\n")
	res += fmt.Sprintf("			}\n")
	res += fmt.Sprintf("		}\n")
	res += fmt.Sprintf("	}\n")
	res += fmt.Sprintf("}\n")
	return res
}

func fieldsHas(fs []def.Field, tString def.TypeID) bool {
	for _, f := range fs {
		if f.Type == tString {
			return true
		}
	}
	return false
}

func getUniqueFields(typ *def.Class) []def.Field {
	res := make([]def.Field, 0, len(typ.Fields))
	for j := range typ.Fields {
		found := false
		fieldCopy := typ.Fields[j]
		fieldCopy.Name = ""
		for i := 0; i < len(res); i++ {
			if res[i].Equals(&fieldCopy) {
				found = true
				break
			}
		}
		if !found {
			res = append(res, fieldCopy)
		}
	}
	return res
}

func getUniqueCpoolFields(typ *def.Class) []def.Field {
	fs := getUniqueFields(typ)
	res := make([]def.Field, 0, len(fs))
	for _, f := range fs {
		if f.ConstantPool {
			res = append(res, f)
		}
	}
	return res
}

func getNonBasicFields(typ *def.Class) []def.Field {

	res := make([]def.Field, 0, len(typ.Fields))
	for _, f := range typ.Fields {
		if f.ConstantPool {
			continue
		}
		if f.Type == T_INT || f.Type == T_LONG || f.Type == T_FLOAT || f.Type == T_BOOLEAN || f.Type == T_STRING {
			continue
		}
		res = append(res, f)
	}
	return res
}

func generateBinding(typ *def.Class, opt options) string {
	tmplText := `
		type {{.BindName}} struct {
			Temp 	{{.Name}}
			Fields	[]{{.BindFieldName}}
		}

		type {{.BindFieldName}} struct {
			Field	*def.Field
			{{range .UniqueFields}}
			{{- goTypeName .}}	*{{if .Array}}[]{{end}}{{goTypeName .}}
			{{end}}
		}

		func New{{.BindName}}(typ *def.Class, typeMap *def.TypeMap) *{{.BindName}} {
			res := new({{.BindName}})
			res.Fields = make([]{{.BindFieldName}}, 0, len(typ.Fields))
			for i := 0; i < len(typ.Fields); i++ {
				switch typ.Fields[i].Name {
				{{- range .Fields}}
				case "{{.Name}}":
					{{- if skipField .Name}}
						res.Fields = append(res.Fields, {{$.BindFieldName}}{Field: &typ.Fields[i]}) // skip to save mem
					{{- else}}
						if typ.Fields[i].Equals(&def.Field{Name: "{{.Name}}", Type: typeMap.{{typeID2Sym .Type}}, ConstantPool: {{.ConstantPool}}, Array: {{.Array}}}) {
							res.Fields = append(res.Fields, {{$.BindFieldName}}{Field: &typ.Fields[i], {{goTypeName .}}: &res.Temp.{{capitalize .Name}}})
						} else {
							res.Fields = append(res.Fields, {{$.BindFieldName}}{Field: &typ.Fields[i]}) // skip changed field
						}
					{{- end}}
				{{- end}}
				default:
					res.Fields = append(res.Fields, {{.BindFieldName}}{Field: &typ.Fields[i]}) // skip unknown new field
				}
			}
			return res
		}
	`

	tmpl, err := template.New("binding").Funcs(template.FuncMap{
		"name":          name,
		"bindName":      bindName,
		"bindFieldName": bindFieldName,
		"goTypeName":    goTypeName,
		"skipField": func(name string) bool {
			return slices.Contains(opt.skipFields, name)
		},
		"typeID2Sym": TypeID2Sym,
		"capitalize": capitalize,
	}).Parse(tmplText)
	if err != nil {
		panic(err)
	}

	var buf bytes.Buffer
	err = tmpl.Execute(&buf, struct {
		Type          *def.Class
		Name          string
		BindName      string
		BindFieldName string
		UniqueFields  []def.Field
		Fields        []def.Field
	}{
		Type:          typ,
		Name:          name(typ),
		BindName:      bindName(typ),
		BindFieldName: bindFieldName(typ),
		UniqueFields:  getUniqueFields(typ),
		Fields:        typ.Fields,
	})
	if err != nil {
		panic(err)
	}

	return buf.String()
}

func emitString() string {
	code := `
	s_, err := util.ParseString(data, &pos)
	if err != nil {
		return 0, err
	}
	_ = s_

`
	return code
}

func emitReadByte() string {
	code := `
	b_, err := util.ParseByte(data, &pos)
	if err != nil {
		return 0, err
	}
	_ = b_

`
	return code

}
func emitReadI32() string {
	code := `
	v32_, err := util.ParseVarInt(data, &pos)
	if err != nil {
		return 0, err
	}
	_ = v32_

`
	return code
}

func emitReadU64() string {
	code := `
	v64_, err := util.ParseVarLong(data, &pos)
	if err != nil {
		return 0, err
	}
	_ = v64_

`
	return code
}

func goTypeName(field def.Field) string {
	if field.ConstantPool {
		//todo array is not tested
		return name(TypeForCPoolID(field.Type)) + "Ref"
	}
	switch field.Type {
	case T_STRING:
		return "string"
	case T_LONG:
		return "uint64"
	case T_INT:
		return "uint32"
	case T_FLOAT:
		return "float32"
	case T_BOOLEAN:
		return "bool"
	case T_STACK_FRAME:
		return "StackFrame" //todo make it generic
	default:
		panic("TODO " + field.String())
	}
}

func name(typ *def.Class) string {
	fs := strings.Split(typ.Name, ".")
	s := fs[len(fs)-1]
	return capitalize(s)
}

func bindName(typ *def.Class) string {
	return "Bind" + name(typ)
}
func bindFieldName(typ *def.Class) string {
	return "BindField" + name(typ)
}
func refName(typ *def.Class) string {
	return name(typ) + "Ref"
}

func listName(typ *def.Class) string {
	return name(typ) + "List"
}

func capitalize(s string) string {
	return strings.ToUpper(s[:1]) + s[1:]
}
