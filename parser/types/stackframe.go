// Code generated by gen/main.go. DO NOT EDIT.

package types

import (
	"fmt"

	"github.com/grafana/jfr-parser/parser/types/def"
	"github.com/grafana/jfr-parser/util"
)

type BindStackFrame struct {
	Temp   StackFrame
	Fields []BindFieldStackFrame
}

type BindFieldStackFrame struct {
	Field        *def.Field
	MethodRef    *MethodRef
	uint32       *uint32
	FrameTypeRef *FrameTypeRef
}

func NewBindStackFrame(typ *def.Class, typeMap *def.TypeMap) *BindStackFrame {
	res := new(BindStackFrame)
	res.Fields = make([]BindFieldStackFrame, 0, len(typ.Fields))
	for i := 0; i < len(typ.Fields); i++ {
		switch typ.Fields[i].Name {
		case "method":
			if typ.Fields[i].Equals(&def.Field{Name: "method", Type: typeMap.T_METHOD, ConstantPool: true, Array: false}) {
				res.Fields = append(res.Fields, BindFieldStackFrame{Field: &typ.Fields[i], MethodRef: &res.Temp.Method})
			} else {
				res.Fields = append(res.Fields, BindFieldStackFrame{Field: &typ.Fields[i]}) // skip changed field
			}
		case "lineNumber":
			if typ.Fields[i].Equals(&def.Field{Name: "lineNumber", Type: typeMap.T_INT, ConstantPool: false, Array: false}) {
				res.Fields = append(res.Fields, BindFieldStackFrame{Field: &typ.Fields[i], uint32: &res.Temp.LineNumber})
			} else {
				res.Fields = append(res.Fields, BindFieldStackFrame{Field: &typ.Fields[i]}) // skip changed field
			}
		case "bytecodeIndex":
			res.Fields = append(res.Fields, BindFieldStackFrame{Field: &typ.Fields[i]}) // skip to save mem
		case "type":
			res.Fields = append(res.Fields, BindFieldStackFrame{Field: &typ.Fields[i]}) // skip to save mem
		default:
			res.Fields = append(res.Fields, BindFieldStackFrame{Field: &typ.Fields[i]}) // skip unknown new field
		}
	}
	return res
}

type StackFrame struct {
	Method     MethodRef
	LineNumber uint32
	// skip bytecodeIndex
	// skip type
}

func (this *StackFrame) Parse(data []byte, bind *BindStackFrame, typeMap *def.TypeMap) (pos int, err error) {
	for bindFieldIndex := 0; bindFieldIndex < len(bind.Fields); bindFieldIndex++ {
		bindArraySize := 1
		if bind.Fields[bindFieldIndex].Field.Array {
			v32_, err := util.ParseVarInt(data, &pos)
			if err != nil {
				return 0, err
			}
			bindArraySize = int(v32_)
		}
		for bindArrayIndex := 0; bindArrayIndex < bindArraySize; bindArrayIndex++ {
			if bind.Fields[bindFieldIndex].Field.ConstantPool {
				v32_, err := util.ParseVarInt(data, &pos)
				if err != nil {
					return 0, err
				}
				switch bind.Fields[bindFieldIndex].Field.Type {
				case typeMap.T_METHOD:
					if bind.Fields[bindFieldIndex].MethodRef != nil {
						*bind.Fields[bindFieldIndex].MethodRef = MethodRef(v32_)
					}
				case typeMap.T_FRAME_TYPE:
					if bind.Fields[bindFieldIndex].FrameTypeRef != nil {
						*bind.Fields[bindFieldIndex].FrameTypeRef = FrameTypeRef(v32_)
					}
				}
			} else {
				bindFieldTypeID := bind.Fields[bindFieldIndex].Field.Type
				switch bindFieldTypeID {
				case typeMap.T_STRING:
					s_, err := util.ParseString(data, &pos)
					if err != nil {
						return 0, err
					}
					// skipping
					_ = s_
				case typeMap.T_INT:
					v32_, err := util.ParseVarInt(data, &pos)
					if err != nil {
						return 0, err
					}
					if bind.Fields[bindFieldIndex].uint32 != nil {
						*bind.Fields[bindFieldIndex].uint32 = v32_
					}
				case typeMap.T_LONG:
					v64_, err := util.ParseVarLong(data, &pos)
					if err != nil {
						return 0, err
					}
					// skipping
					_ = v64_
				case typeMap.T_BOOLEAN:
					b_, err := util.ParseByte(data, &pos)
					if err != nil {
						return 0, err
					}
					// skipping
					_ = b_
				case typeMap.T_FLOAT:
					v32_, err := util.ParseVarInt(data, &pos)
					if err != nil {
						return 0, err
					}
					// skipping
					_ = v32_
				default:
					bindFieldType := typeMap.IDMap[bind.Fields[bindFieldIndex].Field.Type]
					if bindFieldType == nil || len(bindFieldType.Fields) == 0 {
						return 0, fmt.Errorf("unknown type %d", bind.Fields[bindFieldIndex].Field.Type)
					}
					bindSkipObjects := 1
					if bind.Fields[bindFieldIndex].Field.Array {
						v32_, err := util.ParseVarInt(data, &pos)
						if err != nil {
							return 0, err
						}
						bindSkipObjects = int(v32_)
					}
					for bindSkipObjectIndex := 0; bindSkipObjectIndex < bindSkipObjects; bindSkipObjectIndex++ {
						for bindskipFieldIndex := 0; bindskipFieldIndex < len(bindFieldType.Fields); bindskipFieldIndex++ {
							bindSkipFieldType := bindFieldType.Fields[bindskipFieldIndex].Type
							if bindFieldType.Fields[bindskipFieldIndex].ConstantPool {
								_, err := util.ParseVarInt(data, &pos)
								if err != nil {
									return 0, err
								}
							} else if bindSkipFieldType == typeMap.T_STRING {
								_, err := util.ParseString(data, &pos)
								if err != nil {
									return 0, err
								}
							} else if bindSkipFieldType == typeMap.T_INT {
								_, err := util.ParseVarInt(data, &pos)
								if err != nil {
									return 0, err
								}
							} else if bindSkipFieldType == typeMap.T_FLOAT {
								_, err := util.ParseVarInt(data, &pos)
								if err != nil {
									return 0, err
								}
							} else if bindSkipFieldType == typeMap.T_LONG {
								_, err := util.ParseVarLong(data, &pos)
								if err != nil {
									return 0, err
								}
							} else if bindSkipFieldType == typeMap.T_BOOLEAN {
								_, err := util.ParseByte(data, &pos)
								if err != nil {
									return 0, err
								}
							} else {
								return 0, fmt.Errorf("nested objects not implemented. ")
							}
						}
					}
				}
			}
		}
	}

	*this = bind.Temp
	return pos, nil
}
